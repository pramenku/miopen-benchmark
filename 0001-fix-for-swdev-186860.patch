From 99690089e694d3f8893cc5822081e69c0041ec91 Mon Sep 17 00:00:00 2001
From: Maneesh Gupta <maneesh.gupta@amd.com>
Date: Thu, 2 May 2019 12:19:38 +0530
Subject: [PATCH] fix for swdev-186860

Change-Id: Icd65f383f217ee1b647ce73928d7f92b562ddc3d
---
 include/hip/hcc_detail/program_state.hpp | 92 ++++++++++++++++++--------------
 src/hip_hcc.cpp                          | 10 ++++
 2 files changed, 63 insertions(+), 39 deletions(-)

diff --git a/include/hip/hcc_detail/program_state.hpp b/include/hip/hcc_detail/program_state.hpp
index f05f41d..e2af156 100644
--- a/include/hip/hcc_detail/program_state.hpp
+++ b/include/hip/hcc_detail/program_state.hpp
@@ -85,6 +85,8 @@ inline constexpr bool operator==(hsa_isa_t x, hsa_isa_t y) {
 namespace hip_impl {
 
 std::vector<hsa_agent_t> all_hsa_agents();
+std::vector<hsa_executable_t>& executables_cache(std::string, hsa_isa_t, hsa_agent_t);
+extern std::mutex executables_cache_mutex;
 
 class Kernel_descriptor {
     std::uint64_t kernel_object_{};
@@ -143,13 +145,13 @@ ELFIO::section* find_section_if(ELFIO::elfio& reader, P p) {
 inline
 __attribute__((visibility("hidden")))
 const std::unordered_map<
-    hsa_isa_t, std::vector<std::vector<char>>>& code_object_blobs() {
-    static std::unordered_map<hsa_isa_t, std::vector<std::vector<char>>> r;
+    std::string, std::unordered_map<
+        hsa_isa_t, std::vector<std::vector<char>>>>& code_object_blobs() {
+    static std::unordered_map<std::string, std::unordered_map<
+        hsa_isa_t, std::vector<std::vector<char>>>> r;
     static std::once_flag f;
 
     std::call_once(f, []() {
-        static std::vector<std::vector<char>> blobs{};
-
         dl_iterate_phdr([](dl_phdr_info* info, std::size_t, void*) {
             ELFIO::elfio tmp;
 
@@ -164,25 +166,22 @@ const std::unordered_map<
 
             if (!it) return 0;
 
-            blobs.emplace_back(it->get_data(), it->get_data() + it->get_size());
-
-            return 0;
-        }, nullptr);
-
-        for (auto&& multi_arch_blob : blobs) {
-            auto it = multi_arch_blob.begin();
-            while (it != multi_arch_blob.end()) {
-                Bundled_code_header tmp{it, multi_arch_blob.end()};
+            std::vector<char> multi_arch_blob(it->get_data(), it->get_data() + it->get_size());
+            auto blob_it = multi_arch_blob.begin();
+            while (blob_it != multi_arch_blob.end()) {
+                Bundled_code_header tmp{blob_it, multi_arch_blob.end()};
 
                 if (!valid(tmp)) break;
 
                 for (auto&& bundle : bundles(tmp)) {
-                    r[triple_to_hsa_isa(bundle.triple)].push_back(bundle.blob);
+                    r[elf][triple_to_hsa_isa(bundle.triple)].push_back(bundle.blob);
                 }
 
-                it += tmp.bundled_code_size;
+                blob_it += tmp.bundled_code_size;
             };
-        }
+
+            return 0;
+        }, nullptr);
     });
 
     return r;
@@ -399,29 +398,42 @@ const std::vector<hsa_executable_t>& executables(hsa_agent_t agent) {
 
     std::call_once(r[agent].first, [](hsa_agent_t aa) {
         hsa_agent_iterate_isas(aa, [](hsa_isa_t x, void* pa) {
-            const auto it = code_object_blobs().find(x);
-
-            if (it == code_object_blobs().cend()) return HSA_STATUS_SUCCESS;
-
-            hsa_agent_t a = *static_cast<hsa_agent_t*>(pa);
-
-            for (auto&& blob : it->second) {
-                hsa_executable_t tmp = {};
-
-                hsa_executable_create_alt(
-                    HSA_PROFILE_FULL,
-                    HSA_DEFAULT_FLOAT_ROUNDING_MODE_DEFAULT,
-                    nullptr,
-                    &tmp);
-
-                // TODO: this is massively inefficient and only meant for
-                // illustration.
-                std::string blob_to_str{blob.cbegin(), blob.cend()};
-                tmp = load_executable(blob_to_str, tmp, a);
-
-                if (tmp.handle) r[a].second.push_back(tmp);
+            for (const auto code_object_it : code_object_blobs()) {
+                const auto elf = code_object_it.first;
+                const auto it = code_object_it.second.find(x);
+
+                if (it == code_object_it.second.cend()) continue;
+
+                hsa_agent_t a = *static_cast<hsa_agent_t*>(pa);
+
+                std::lock_guard<std::mutex> lck{executables_cache_mutex};
+                std::vector<hsa_executable_t>& current_exes =
+                        hip_impl::executables_cache(elf, x, a);
+                // check the cache for already loaded executables
+                if (current_exes.empty()) {
+                    // executables do not yet exist for this elf+isa+agent, create and cache them
+                    for (auto&& blob : it->second) {
+                        hsa_executable_t tmp = {};
+
+                        hsa_executable_create_alt(
+                            HSA_PROFILE_FULL,
+                            HSA_DEFAULT_FLOAT_ROUNDING_MODE_DEFAULT,
+                            nullptr,
+                            &tmp);
+
+                        // TODO: this is massively inefficient and only meant for
+                        // illustration.
+                        std::string blob_to_str{blob.cbegin(), blob.cend()};
+                        tmp = load_executable(blob_to_str, tmp, a);
+
+                        if (tmp.handle) {
+                            current_exes.push_back(tmp);
+                        }
+                    }
+                }
+                // append cached executables to our agent's vector of executables
+                r[a].second.insert(r[a].second.end(), current_exes.begin(), current_exes.end());
             }
-
             return HSA_STATUS_SUCCESS;
         }, &aa);
     }, agent);
@@ -655,7 +667,8 @@ const std::unordered_map<
     static std::once_flag f;
 
     std::call_once(f, []() {
-        for (auto&& isa_blobs : code_object_blobs()) {
+        for (auto&& name_and_isa_blobs : code_object_blobs()) {
+          for (auto&& isa_blobs : name_and_isa_blobs.second) {
             for (auto&& blob : isa_blobs.second) {
                 std::stringstream tmp{std::string{blob.cbegin(), blob.cend()}};
 
@@ -665,6 +678,7 @@ const std::unordered_map<
 
                 read_kernarg_metadata(reader, r);
             }
+          }
         }
     });
 
diff --git a/src/hip_hcc.cpp b/src/hip_hcc.cpp
index ac285e6..31f6c92 100644
--- a/src/hip_hcc.cpp
+++ b/src/hip_hcc.cpp
@@ -2524,4 +2524,14 @@ namespace hip_impl {
             std::terminate();
         #endif
     }
+
+    std::mutex executables_cache_mutex;
+
+    std::vector<hsa_executable_t>& executables_cache(
+            std::string elf, hsa_isa_t isa, hsa_agent_t agent) {
+        static std::unordered_map<std::string,
+            std::unordered_map<hsa_isa_t,
+                std::unordered_map<hsa_agent_t, std::vector<hsa_executable_t>>>> cache;
+        return cache[elf][isa][agent];
+    }
 } // Namespace hip_impl.
-- 
2.7.4

